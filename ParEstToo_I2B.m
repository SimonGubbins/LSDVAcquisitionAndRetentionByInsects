function ParEstToo_I2B(nF,seeds,nchains,nsamp,nburnin,nthin)
%
% ParEstToo_I2B(nF,seeds,nchains,nsamp,nburnin,nthin)
%
% Matlab function to implement a Bayesian MCMC scheme to estimate the
% probability of transmission from insect to bovine for LSDV in Stomoxys
% calcitrans.
%
% This version uses both the Chihota and the Sciensano data.
%
% Inputs:
% nF - maximum number of insects feeding when transmitting LSDV to
%      cattle in the Chihota experiment (set to zero to exclude these data
%      from the analysis)
% seeds - vector of seeds for the random number generator used by each
%         chain (must be on length nchains)
% nchains - number of chains to run
% nsamp - number of samples to use when estimating parameters
% nburnin - number of samples to discard before estimating parameters
% nthin - number of samples by which to thin each chain
%
% Outputs: none (N.B. All chains are saved rather than provided as output
% arguments)

%==========================================================================
% PREPARATORY STUFF
% Load the Chihota data
chihotaD=load('ChihotaData_SCalc.txt');
chihotaD(:,2)=nF;

% Load the Sciensano data
recipList=load('SciensanoData_RecipientList.txt');
tOnset=load('SciensanoData_TimeOfOnset.txt');
D=load('SciensanoData_ChallengeData.txt');
delta=1/24;   % time between initial feed and refeed (in days)
D={recipList; tOnset; D; delta};

% Create the informative priors for virus inactivation rate (1), the
% probability of transmission from bovine to insect (2) and the relative
% risk of a subclinical bovine (3)
% (NOTE: these are generated by running ParEst_B2I)
priorPDF=cell(1,4);
varload=load('B2IModel6_MCMCSamples');
PS=[varload.ParSamp{1}(:,[4 5 6]); varload.ParSamp{2}(:,[4 5 6])];
priorPDF{1}=fitdist(PS(:,1),'kernel','support','positive');
priorPDF{2}=fitdist(PS(:,2),'kernel','support',[0 1]);
priorPDF{3}=fitdist(PS(:,3),'kernel','support','positive');
clear('PS')

% Create the informative priors for the onset of viraemia
% (NOTE: these are generated by running ParEst_DurEI)
varload=load('DurEI_MCMCSamples');
PS=[varload.onsetBloodPCR{1}(:,1:2); varload.onsetBloodPCR{2}(:,1:2)];
priorPDF{4}=fitdist(PS(:,1),'kernel','support','positive');
priorPDF{5}=fitdist(PS(:,2),'kernel','support','positive');

% Set the number of parameters
npar=7+size(chihotaD,1)+size(D{3},1);

% Create the arrays storing the output for the chain
ParSamp=cell(1,nchains);
%==========================================================================

% For each chain ...
parfor chain=1:nchains

%==========================================================================
% INITIALISE THE CHAIN
% Initialise the random number generator
    rng(seeds(chain),'twister');

% Set the initial scaling factor for the proposal distribution
    sf=(2.38.^2)/npar;
    SIG=eye(npar);
    
% Set the counter for the number of accepted samples
    n_accept=0;

% Create the arrays storing the output for the chain
    ParSampC=zeros(nsamp/nthin,npar+2);
    iter=1;

% Generate the initial parameters for the chain, ensuring they generate a
% finite log likelihood and prior
    disp('Initialising chain')
    CurrL=NaN;
    prior=NaN;
    while ~isfinite(CurrL+prior)

% Sample an initial set of transmission parameters
        g=unifrnd(0,5);
        bHV=unifrnd(0,1);
        rr=unifrnd(0,0.05);
        bVH=unifrnd(0,1);

% Sample an initial set of parameters for the duration of viraemia
        u=unidrnd(size(PS,1));
        kE=PS(u,1);
        muE=PS(u,2);

% Sample an initial probability of refeeding
        a=unifrnd(0,1);
        nRF1=binornd(D{3}(:,4),1-exp(-a.*D{4}));
        nRF2=binornd(chihotaD(:,2),1-exp(-a.*chihotaD(:,1)));
        
% Combine them
        par=[g; bHV; rr; bVH; kE; muE; a; nRF1; nRF2];

% Compute the log-likelihood
        [CurrL, prior]=LhoodToo_I2B(par,D,chihotaD,priorPDF);

    end
%==========================================================================

%==========================================================================
% UPDATE THE PARAMETERS
% Sample parameter space
    disp('Sampling parameter space')
    for samp=1:nsamp+nburnin

% Indicate what's going on
        disp(['Chain: ' num2str(chain) ', Sample: ' num2str(samp) ';'...
              ' Accept: ' num2str(100*n_accept/samp,3) '%'])

% Update the variance-covariance matrix for the proposal distribution
        if samp<=nburnin && (samp<=2*npar || n_accept==0)
            SIGp=0.01*eye(npar);
        else
            SIGp=sf.*(SIG+0.01*eye(npar));
        end

% Generate the new set of probabilities
        par_new=par+mvnrnd(zeros(1,length(par)),SIGp)';

% Compute the log likelihood and prior for the new parameter set
        [NewL, prior_new]=LhoodToo_I2B(par_new,D,chihotaD,priorPDF);

% Test whether to accept the new parameter set
        u=unifrnd(0,1);
        if isfinite(NewL+prior_new) && ...
           u<min(1,exp((NewL+prior_new)-(CurrL+prior)))

% Update the counter
            n_accept=n_accept+1;

% Update the covariance matrix for the proposal distribution
            if n_accept==1
                pbar=mean([par par_new],2);
                SIG=cov([par'; par_new']);
            elseif samp<=nburnin && n_accept>1
                pbar_prev=pbar;
                pbar=(n_accept./(n_accept+1)).*pbar_prev+...
                     (1./(n_accept+1)).*par_new;
                SIG=((n_accept-1)./n_accept).*SIG+...
                    (1./n_accept).*(n_accept.*(pbar_prev*pbar_prev')-...
                                    (n_accept+1).*(pbar*pbar')+...
                                    (par_new*par_new'));
            end

% Update the chain
            CurrL=NewL;
            prior=prior_new;
            par=par_new;

        end

% Every one hundred samples during burn-in, tune the scaling factor
% for the proposal distribution to ensure an acceptance rate of 20-40%
        if samp<=nburnin && mod(samp+1,100)==1 && n_accept/samp<0.2
            sf=sf/2;
        elseif samp<=nburnin && mod(samp+1,100)==1 && n_accept/samp>0.4
            sf=2*sf;
        end
%==========================================================================

%==========================================================================
% STORE THE OUTPUT
% After burn in, save iterations of the chain, thinning as specified
        if nthin==1
            ParSampC(samp,:)=[par' prior CurrL];
        elseif samp>nburnin && mod(samp,nthin)==1
            ParSampC(iter,:)=[par' prior CurrL];
            iter=iter+1;
        end
%==========================================================================

    end

% Store the chain
    ParSamp{chain}=ParSampC;

end

%==========================================================================
% SAVE THE CHAINS
% Set the filename
fName=['SCalc_I2BToo_MCMCSamples_N=' num2str(nF)];

% Save the outputs
save(fName,'ParSamp','nburnin','nsamp','seeds')
%==========================================================================
